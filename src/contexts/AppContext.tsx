
"use client";

import type React from 'react';
import { createContext, useContext, useState, useCallback, useEffect, useRef } from 'react';
import type { Claim, AppNotification, ClaimStatus, ConsistencyReport, ExtractedFieldWithOptionalBox, AssessFraudRiskOutput } from '@/lib/types';
import { assessFraudRisk } from '@/ai/flows/fraud-assessment';
import { extractDocumentInformation } from '@/ai/flows/document-processing';
import { qaOnDocument } from '@/ai/flows/qa-on-document';
import { db } from '@/lib/firebase';
import {
  collection,
  getDocs,
  doc,
  setDoc,
  updateDoc,
  writeBatch,
  query,
  orderBy,
  Timestamp
} from 'firebase/firestore';

// Helper to process raw seed data into full Claim objects for initial state
const processSeedForInitialState = (
  seedArray: (Partial<Omit<Claim, 'submissionDate' | 'lastUpdatedDate' | 'id'>> & { id: string })[]
): Claim[] => {
  return seedArray.map((claimData, index) => {
    const submissionDate = new Date(Date.now() - (seedArray.length - 1 - index) * 24 * 60 * 60 * 1000 * (3 + index)).toISOString();
    const lastUpdatedDate = claimData.status && claimData.status !== 'Pending' ?
      new Date(new Date(submissionDate).getTime() + (Math.random() * 24 + 12) * 60 * 60 * 1000).toISOString() :
      submissionDate;

    let finalDocumentUri = claimData.documentUri;
    if ((!finalDocumentUri || finalDocumentUri.startsWith('https://placehold.co')) && claimData.documentName) {
      const textContent = `Document: ${claimData.documentName}\nType: ${claimData.documentName.split('.').pop() || 'unknown'}\nClaimant: ${claimData.claimantName}\nPolicy Number: ${claimData.policyNumber}\nIncident Date: ${claimData.incidentDate}\nDescription: ${claimData.incidentDescription}`;
      finalDocumentUri = `data:text/plain;base64,${btoa(unescape(encodeURIComponent(textContent)))}`;
    }

    const imageUris = claimData.imageUris && claimData.imageUris.length > 0 ? claimData.imageUris
                      : claimData.imageNames && claimData.imageNames.length > 0
                      ? claimData.imageNames.map((name, i) => `https://placehold.co/150x100.png?text=${encodeURIComponent(name.substring(0,10))}${i+1}`)
                      : [];

    const videoUri = claimData.videoUri ? claimData.videoUri
                      : claimData.videoName
                      ? `https://placehold.co/160x90.png?text=${encodeURIComponent(claimData.videoName.substring(0,10))}`
                      : undefined; // Will be handled as null for Firestore if undefined

    return {
      id: claimData.id!,
      claimantName: claimData.claimantName || "Default Claimant",
      policyNumber: claimData.policyNumber || "POL-000",
      incidentDate: claimData.incidentDate || new Date().toISOString().split('T')[0],
      incidentDescription: claimData.incidentDescription || "No description.",
      status: claimData.status || "Pending",
      documentName: claimData.documentName,
      documentUri: finalDocumentUri,
      imageNames: claimData.imageNames || [],
      imageUris: imageUris,
      videoName: claimData.videoName,
      videoUri: videoUri,
      extractedInfo: claimData.extractedInfo || defaultExtractedInfo,
      fraudAssessment: claimData.fraudAssessment || defaultFraudAssessment,
      consistencyReport: claimData.consistencyReport || defaultConsistencyReport,
      notes: claimData.notes,
      submissionDate: submissionDate,
      lastUpdatedDate: lastUpdatedDate,
    } as Claim;
  });
};


const staticDemoAppContextClaimsSeed: (Partial<Omit<Claim, 'submissionDate' | 'lastUpdatedDate' | 'id'>> & { id: string })[] = [
  {
    id: 'static_demo_approved_123',
    claimantName: 'Carol Danvers (UI Demo)',
    policyNumber: 'POL-STATIC-001',
    incidentDate: '2024-07-22',
    incidentDescription: 'Lost luggage during international flight. Contents included high-value electronics and personal items.',
    documentName: 'LostLuggage_CD.pdf',
    // documentUri will be generated by processSeed
    imageNames: ['receipt_laptop.jpg', 'receipt_camera.jpg'],
    // imageUris will be generated if not provided
    status: 'Approved',
    extractedInfo: {
      flightNumber: { value: "CX808", boundingBox: { x: 0.1, y: 0.05, width: 0.2, height: 0.03, page: 1 } },
      totalClaimValue: { value: "$2,800", boundingBox: null },
      itemsList: { value: {"laptop": "MacBook Pro 16\"", "camera": "Sony A7IV"}, boundingBox: { x: 0.1, y: 0.25, width: 0.5, height: 0.08, page: 1 } }
    },
    fraudAssessment: { riskScore: 0.01, fraudIndicators: ["None"], summary: "Very low risk. Verified travel itinerary and purchase receipts." },
    consistencyReport: {
      status: 'Consistent',
      summary: 'Claim details, flight information, and purchase receipts align. No discrepancies found.',
      details: [{ documentA: 'LostLuggage_CD.pdf', documentB: 'Airline System Data', field: 'Flight CX808 Status', valueA: 'Confirmed, Luggage Tagged', valueB: 'Confirmed, Luggage Tagged, Reported Missing', finding: 'Match' }]
    },
    notes: 'Approved for full reimbursement. Payment issued.',
  },
  {
    id: 'static_demo_pending_456',
    claimantName: 'Peter Parker (UI Demo)',
    policyNumber: 'POL-STATIC-002',
    incidentDate: '2024-07-21',
    incidentDescription: 'Damage to camera equipment during a sudden rooftop incident. Multiple lenses shattered. Drone also damaged.',
    documentName: 'DamageReport_PP.zip',
    imageNames: ['broken_lens_1.jpg', 'damaged_drone.jpg'],
    videoName: 'RooftopIncident_SecurityCam.mp4',
    status: 'Pending',
    extractedInfo: {
      incidentLocation: { value: "Rooftop, Daily Bugle Building (approx.)", boundingBox: null },
      equipmentList: { value: ["Telephoto Lens 70-200mm", "Wide Angle Lens 16-35mm", "DJI Mavic 3 Pro Drone"], boundingBox: null },
      estimatedDamageCost: { value: "$4,500 (preliminary)", boundingBox: { x: 0.7, y: 0.8, width: 0.2, height: 0.04, page: 1 } }
    },
    fraudAssessment: { riskScore: 0.25, fraudIndicators: ["Unusual incident location", "High cost of specialized equipment"], summary: "Low-to-moderate risk. Claimant has a history of similar small claims. Nature of incident requires corroboration if possible. Images show damage consistent with impact." },
    consistencyReport: {
      status: 'Partial',
      summary: 'Equipment listed is consistent with policy endorsements. Incident date plausible. Awaiting police report or further witness statements if available for incident circumstances.',
      details: [
        { documentA: 'DamageReport_PP.zip', documentB: 'Policy Endorsements', field: 'Listed Equipment Coverage', valueA: 'Covered', valueB: 'Covered', finding: 'Match' },
        { documentA: 'DamageReport_PP.zip', documentB: 'Police Report (if filed)', field: 'Incident Corroboration', valueA: 'Details provided by claimant', valueB: 'Not yet received/cross-referenced', finding: 'Not Compared' }
      ]
    },
    notes: 'Awaiting adjuster review and any external reports.',
  }
];

const initialProcessedStaticClaims = processSeedForInitialState(staticDemoAppContextClaimsSeed);

// Firestore Seeding Data (different from initial static state to show DB override)
const initialClaimsSeedForFirestore: (Partial<Omit<Claim, 'submissionDate' | 'lastUpdatedDate' | 'id'>> & { id: string })[] = [
  {
    id: 'clm_fs_alice_123',
    claimantName: 'Alice Wonderland (FS)',
    policyNumber: 'POL-FS-001',
    incidentDate: '2024-07-15',
    incidentDescription: 'Minor fender bender in parking lot. Scratches on rear bumper. From Firestore.',
    documentName: 'AccidentReport_FS.pdf',
    // documentUri will be generated
    imageNames: ['fs_damage_front.jpg', 'fs_damage_side.jpg'],
    // imageUris will be generated
    videoName: 'fs_dashcam_footage.mp4',
    // videoUri will be generated
    status: 'Pending',
    extractedInfo: { policyNumber: { value: "POL-FS-001" } },
    fraudAssessment: { riskScore: 0.1, fraudIndicators: ["Low impact"], summary: "Low risk (FS)." },
    consistencyReport: { status: 'Consistent', summary: 'Details align (FS).' },
    notes: 'Awaiting FS adjuster review.',
  },
  {
    id: 'clm_fs_bob_456',
    claimantName: 'Bob The Builder (FS)',
    policyNumber: 'POL-FS-002',
    incidentDate: '2024-07-18',
    incidentDescription: 'Water damage from burst pipe in kitchen. From Firestore.',
    documentName: 'PlumberInvoice_FS.pdf',
    // documentUri will be generated
    // No imageNames or imageUris specified for Bob, should default to empty arrays
    // No videoName or videoUri specified for Bob, should default to null
    status: 'Approved',
    extractedInfo: { invoiceTotal: { value: "$550" } },
    fraudAssessment: { riskScore: 0.05, fraudIndicators: [], summary: "Approved (FS)." },
    consistencyReport: { status: 'Consistent', summary: 'All good (FS).' },
    notes: 'FS Payment processed.',
  },
];


const initialNotifications: AppNotification[] = [
  { id: 'notif_1749303223456', title: 'Claim Submitted', message: 'Claim #static_demo_approved_123... by Carol Danvers received.', type: 'success', timestamp: new Date('2024-07-20T10:00:00Z').toISOString(), read: false, claimId: 'static_demo_approved_123' },
  { id: 'notif_1749303223789', title: 'Claim Status Update', message: 'Claim #static_demo_pending_456... for Peter Parker is now Under Review.', type: 'info', timestamp: new Date('2024-07-22T09:15:00Z').toISOString(), read: true, claimId: 'static_demo_pending_456' },
];


interface NewClaimFormData {
  claimantName: string;
  policyNumber: string;
  incidentDate: string;
  incidentDescription: string;
  documentUri?: string;
  documentName?: string;
  imageUris?: string[];
  imageNames?: string[];
  videoUri?: string;
  videoName?: string;
}

interface AppContextType {
  claims: Claim[];
  notifications: AppNotification[];
  addClaim: (newClaimData: NewClaimFormData) => Promise<Claim | null>;
  updateClaimStatus: (claimId: string, status: ClaimStatus, notes?: string) => Promise<void>;
  getClaimById: (claimId: string) => Claim | undefined;
  addNotification: (notification: Omit<AppNotification, 'id' | 'timestamp' | 'read'>) => void;
  markNotificationAsRead: (notificationId: string) => void;
  clearNotifications: () => void;
  isLoading: boolean;
  isContextLoading: boolean;
  isKycVerifiedForSession: boolean;
  completeKycSession: () => void;
  resetKycSession: () => void;
  askQuestionOnDocument: (documentDataUri: string, question: string, claimId?: string) => Promise<string | null>;
  qaAnswer: string | null;
  isAskingQuestion: boolean;
  clearQaAnswer: () => void;
}

const AppContext = createContext<AppContextType | undefined>(undefined);

const defaultExtractedInfo: Record<string, ExtractedFieldWithOptionalBox> = {
  processingStatus: { value: "Extraction not performed, failed, or no document provided." }
};

const defaultFraudAssessment: AssessFraudRiskOutput = {
  riskScore: 0,
  fraudIndicators: ["Assessment Not Performed"],
  summary: "Fraud assessment was not performed or encountered an error."
};

const defaultConsistencyReport: ConsistencyReport = {
  status: 'Not Run',
  summary: 'Consistency check was not performed or encountered an error.'
};


export const AppContextProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [claims, setClaims] = useState<Claim[]>(initialProcessedStaticClaims);
  const [notifications, setNotifications] = useState<AppNotification[]>(initialNotifications);
  const [isLoading, setIsLoading] = useState(true);
  const [isKycVerifiedForSession, setIsKycVerifiedForSession] = useState(false);
  const notificationIdCounter = useRef(initialNotifications.length);

  const [qaAnswer, setQaAnswer] = useState<string | null>(null);
  const [isAskingQuestion, setIsAskingQuestion] = useState(false);

  useEffect(() => {
    const fetchAndSeedClaims = async () => {
      setIsLoading(true);
      console.log("AppContext: fetchAndSeedClaims started.");
      const claimsCollectionRef = collection(db, "claims");
      const q = query(claimsCollectionRef, orderBy("submissionDate", "desc"));

      try {
        const querySnapshot = await getDocs(q);
        if (querySnapshot.empty) {
          console.log("AppContext: Firestore 'claims' collection is empty. Seeding initial data from initialClaimsSeedForFirestore...");
          const batch = writeBatch(db);

          const processedSeedForFirestore = processSeedForInitialState(initialClaimsSeedForFirestore);

          processedSeedForFirestore.forEach((processedClaimData) => {
            const docRef = doc(db, "claims", processedClaimData.id);
            const submissionTimestamp = Timestamp.fromDate(new Date(processedClaimData.submissionDate));
            const lastUpdatedTimestamp = Timestamp.fromDate(new Date(processedClaimData.lastUpdatedDate));

            const firestoreReadyClaim = {
              id: processedClaimData.id,
              claimantName: processedClaimData.claimantName,
              policyNumber: processedClaimData.policyNumber,
              incidentDate: processedClaimData.incidentDate,
              incidentDescription: processedClaimData.incidentDescription,
              status: processedClaimData.status,
              submissionDate: submissionTimestamp,
              lastUpdatedDate: lastUpdatedTimestamp,
              documentName: processedClaimData.documentName ?? null,
              documentUri: processedClaimData.documentUri ?? null,
              imageNames: processedClaimData.imageNames || [],
              imageUris: processedClaimData.imageUris || [],
              videoName: processedClaimData.videoName ?? null,
              videoUri: processedClaimData.videoUri ?? null,
              notes: processedClaimData.notes ?? null,
              extractedInfo: processedClaimData.extractedInfo || defaultExtractedInfo,
              fraudAssessment: processedClaimData.fraudAssessment || defaultFraudAssessment,
              consistencyReport: processedClaimData.consistencyReport || defaultConsistencyReport,
            };
            batch.set(docRef, firestoreReadyClaim);
          });
          await batch.commit();
          console.log("AppContext: Initial data (initialClaimsSeedForFirestore) seeded to Firestore.");
          addNotification({title: "Sample Claims Seeded to DB", message: "Initial sample claims have been added to the database.", type: "info"});
          const seededSnapshot = await getDocs(q);
          const fetchedClaims = seededSnapshot.docs.map(docSnap => {
            const data = docSnap.data();
            return {
              ...data,
              id: docSnap.id,
              submissionDate: (data.submissionDate as Timestamp)?.toDate().toISOString(),
              lastUpdatedDate: (data.lastUpdatedDate as Timestamp)?.toDate().toISOString(),
            } as Claim;
          });
          setClaims(fetchedClaims);

        } else {
          console.log("AppContext: Firestore 'claims' collection has data. Fetching...");
          const fetchedClaims = querySnapshot.docs.map(docSnap => {
            const data = docSnap.data();
             let finalDocumentUri = data.documentUri;
             if (!finalDocumentUri && data.documentName) {
                const textContent = `Document: ${data.documentName}\nClaimant: ${data.claimantName}\nPolicy Number: ${data.policyNumber}\nIncident Date: ${data.incidentDate}\nDescription: ${data.incidentDescription}`;
                finalDocumentUri = `data:text/plain;base64,${btoa(unescape(encodeURIComponent(textContent)))}`;
             }

            return {
              ...data,
              id: docSnap.id,
              documentUri: finalDocumentUri,
              submissionDate: (data.submissionDate as Timestamp)?.toDate().toISOString(),
              lastUpdatedDate: (data.lastUpdatedDate as Timestamp)?.toDate().toISOString(),
            } as Claim;
          });
          setClaims(fetchedClaims);
          console.log("AppContext: Claims fetched from Firestore and replaced initial static claims.");
        }
      } catch (error) {
        console.error("AppContext: Error fetching or seeding claims from Firestore:", error);
        addNotification({ title: "Database Error", message: `Could not load claims from Firestore. Displaying demo claims. Details: ${error instanceof Error ? error.message : String(error)}`, type: "error" });
      } finally {
        setIsLoading(false);
        console.log("AppContext: Initial claim fetching/seeding process complete. isLoading set to false.");
      }
    };

    const timer = setTimeout(() => {
        if (process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID && process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID !== "undefined") {
            fetchAndSeedClaims();
        } else {
            console.warn("AppContext: Firebase Project ID is undefined. Firestore operations will fail. Skipping fetchAndSeedClaims. Using static demo claims.");
            addNotification({title: "Firebase Not Configured", message: "Firebase Project ID is missing. Using static demo claims.", type: "warning"});
            setIsLoading(false);
        }
    }, 100);

    return () => clearTimeout(timer);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);


  const addNotification = useCallback((notificationData: Omit<AppNotification, 'id' | 'timestamp' | 'read'>) => {
    notificationIdCounter.current += 1;
    const newNotification: AppNotification = {
      ...notificationData,
      id: `notif_${Date.now()}_${notificationIdCounter.current}`,
      timestamp: new Date().toISOString(),
      read: false,
    };
    setNotifications(prev => [newNotification, ...prev].slice(0, 20));
  }, []);

  const resetKycSession = useCallback(() => {
    setIsKycVerifiedForSession(false);
  }, []);

  const addClaim = useCallback(async (newClaimData: NewClaimFormData): Promise<Claim | null> => {
    console.log("addClaim: Started");
    setIsLoading(true);
    let newClaimId = `clm_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`;

    let currentExtractedInfoResult: Record<string, ExtractedFieldWithOptionalBox> = { ...defaultExtractedInfo };
    let fraudAssessmentResult: AssessFraudRiskOutput = { ...defaultFraudAssessment };
    let consistencyReportResult: ConsistencyReport = { ...defaultConsistencyReport };

    let docTypeForProcessing: string | undefined;
    let isDocDirectlyProcessableForMedia = false;

    try {
      console.log("addClaim: Main try block entered");
      if (newClaimData.documentUri && newClaimData.documentName) {
        console.log("addClaim: Document URI and Name present, starting document processing.");
        const docNameLower = newClaimData.documentName.toLowerCase();
        docTypeForProcessing = docNameLower.endsWith('.pdf') ? 'PDF Document' :
                               docNameLower.match(/\.(jpeg|jpg|png|gif|webp)$/i) ? 'Image' :
                               docNameLower.endsWith('.zip') ? 'ZIP Archive' :
                               (docNameLower.endsWith('.doc') || docNameLower.endsWith('.docx')) ? 'General Document' :
                               'Other Document';

        const mimeTypeMatch = newClaimData.documentUri.match(/^data:(.+?);base64,/);
        if (mimeTypeMatch && mimeTypeMatch[1]) {
          const mimeType = mimeTypeMatch[1];
          const supportedMimeTypesForMediaHelper = [
            'image/jpeg', 'image/png', 'image/webp', 'image/gif',
            'application/pdf', 'text/plain',
          ];
          if (supportedMimeTypesForMediaHelper.includes(mimeType)) {
            isDocDirectlyProcessableForMedia = true;
          }
        }
        if (docTypeForProcessing === 'General Document' || docTypeForProcessing === 'ZIP Archive' || docTypeForProcessing === 'Other Document') {
            isDocDirectlyProcessableForMedia = false;
        }
        console.log(`addClaim: Document type determined: ${docTypeForProcessing}, Directly processable for media: ${isDocDirectlyProcessableForMedia}`);

        console.log("addClaim: Before extractDocumentInformation call");
        const extractionInput = {
          documentDataUri: newClaimData.documentUri,
          documentType: docTypeForProcessing,
          documentName: newClaimData.documentName,
          isDirectlyProcessableMedia: isDocDirectlyProcessableForMedia,
        };
        const extractionOutput = await extractDocumentInformation(extractionInput);
        console.log("addClaim: After extractDocumentInformation call", extractionOutput);
        if (extractionOutput && extractionOutput.extractedFieldsJson) {
           try {
              const parsedJson = JSON.parse(extractionOutput.extractedFieldsJson);
              currentExtractedInfoResult = parsedJson as Record<string, ExtractedFieldWithOptionalBox>;
              addNotification({ title: 'Document Processed', message: `Info extracted from ${newClaimData.documentName}.`, type: 'success', claimId: newClaimId });
            } catch (e) {
              console.error("Failed to parse extractedFieldsJson string:", e);
              currentExtractedInfoResult = { parsingError: { value: "Failed to parse AI response for extracted information." }, ...defaultExtractedInfo };
              addNotification({ title: 'Document Parsing Error', message: `Could not parse extracted info for ${newClaimData.documentName}. Invalid JSON.`, type: 'error', claimId: newClaimId });
            }
        } else {
           console.log("addClaim: Document extraction returned no JSON or was skipped.");
           currentExtractedInfoResult = { ...defaultExtractedInfo, processingStatus: {value: "Extraction did not return expected JSON data or was skipped."}};
           addNotification({ title: 'Document Processing Skipped', message: `No information extracted from ${newClaimData.documentName}.`, type: 'info', claimId: newClaimId });
        }
      } else {
        console.log("addClaim: No document URI or name provided. Skipping document processing.");
        currentExtractedInfoResult = { ...defaultExtractedInfo, processingStatus: {value: "No document was provided for extraction."}};
      }

      console.log("addClaim: Before assessFraudRisk call");
      const assessmentInput = {
        claimDetails: `${newClaimData.claimantName} - ${newClaimData.incidentDescription}. Policy: ${newClaimData.policyNumber}. Incident Date: ${newClaimData.incidentDate}. Extracted Info: ${JSON.stringify(currentExtractedInfoResult || {})}`,
        supportingDocumentUri: newClaimData.documentUri,
        supportingDocumentName: newClaimData.documentName,
        supportingDocumentType: docTypeForProcessing,
        isSupportingDocumentDirectlyProcessable: isDocDirectlyProcessableForMedia,
        imageEvidenceUris: newClaimData.imageUris,
        videoEvidenceUri: newClaimData.videoUri,
      };
      const aiOutput = await assessFraudRisk(assessmentInput);
      console.log("addClaim: After assessFraudRisk call", aiOutput);
      if (aiOutput) {
          fraudAssessmentResult = aiOutput;
          addNotification({ title: 'Fraud Assessment Complete', message: `Risk score: ${fraudAssessmentResult.riskScore.toFixed(2)} for claim by ${newClaimData.claimantName}.`, type: 'info', claimId: newClaimId });
      } else {
          console.log("addClaim: Fraud assessment returned no data.");
          fraudAssessmentResult = { ...defaultFraudAssessment, summary: "AI returned no data for fraud assessment."};
          addNotification({ title: 'Fraud Assessment Incomplete', message: `AI returned no data for fraud assessment of ${newClaimData.claimantName}'s claim.`, type: 'warning', claimId: newClaimId });
      }


      console.log("addClaim: Simulating consistency report");
      if (newClaimData.documentUri && currentExtractedInfoResult !== defaultExtractedInfo && fraudAssessmentResult !== defaultFraudAssessment) {
        const isConsistent = Math.random() > 0.4;
        const primaryDocName = newClaimData.documentName || "Submitted Claim Document";
        const secondaryDocTypes = ["Police Report (on file)", "Witness Statement (on file)", "Internal System Record"];
        const secondaryDocName = secondaryDocTypes[Math.floor(Math.random() * secondaryDocTypes.length)];
        const commonFields = ["Incident Date", "Claimant Name", "Policy Number"];
        const fieldForComparison = commonFields[Math.floor(Math.random() * commonFields.length)];

        const getExtractedValue = (fieldName: string) => {
            const key = Object.keys(currentExtractedInfoResult || {}).find(k => k.toLowerCase().replace(/\s/g, '') === fieldName.toLowerCase().replace(/\s/g, ''));
            return key ? String((currentExtractedInfoResult?.[key] as ExtractedFieldWithOptionalBox)?.value || "N/A") : String(newClaimData[fieldName.toLowerCase().replace(/\s/g, '') as keyof NewClaimFormData] || "N/A");
        };

        if (isConsistent) {
          consistencyReportResult = {
            status: 'Consistent',
            summary: `Key details (e.g., Claimant Name, ${fieldForComparison}) appear consistent between ${primaryDocName} and ${secondaryDocName}.`,
            details: [ { documentA: primaryDocName, documentB: secondaryDocName, field: fieldForComparison, valueA: getExtractedValue(fieldForComparison), valueB: getExtractedValue(fieldForComparison), finding: 'Match' } ]
          };
        } else {
          const valueA = getExtractedValue(fieldForComparison);
          let valueB = "Different Value B - " + Math.random().toString(36).substring(7);
          if (fieldForComparison === "Incident Date" && newClaimData.incidentDate) { valueB = new Date(Date.parse(newClaimData.incidentDate) - (Math.floor(Math.random() * 5) + 1) * 24 * 60 * 60 * 1000).toISOString().split('T')[0]; }
          else if (fieldForComparison === "Claimant Name") { valueB = newClaimData.claimantName.split(" ")[0] + " Smithson"; }
          consistencyReportResult = { status: 'Inconsistent', summary: `Discrepancy noted in "${fieldForComparison}" between ${primaryDocName} and ${secondaryDocName}. Review recommended.`, details: [{ documentA: primaryDocName, documentB: secondaryDocName, field: fieldForComparison, valueA: valueA, valueB: valueB, finding: 'Mismatch', }], };
        }
        addNotification({ title: 'Consistency Check Simulated', message: `Consistency: ${consistencyReportResult.status} for ${newClaimData.claimantName}'s claim.`, type: 'info', claimId: newClaimId });
      } else if (newClaimData.documentUri) {
          consistencyReportResult = { ...defaultConsistencyReport, status: 'Not Run', summary: 'Consistency check requires full AI analysis of all related documents. Main document uploaded.' };
      } else {
          consistencyReportResult = { ...defaultConsistencyReport, status: 'Not Run', summary: 'No document uploaded; consistency check not performed.' };
      }

      const now = Timestamp.now();
      const newClaimForDb = {
        id: newClaimId,
        claimantName: newClaimData.claimantName,
        policyNumber: newClaimData.policyNumber,
        incidentDate: newClaimData.incidentDate,
        incidentDescription: newClaimData.incidentDescription,
        documentName: newClaimData.documentName ?? null,
        documentUri: newClaimData.documentUri ?? null,
        imageNames: newClaimData.imageNames || [],
        imageUris: newClaimData.imageUris || [],
        videoName: newClaimData.videoName ?? null,
        videoUri: newClaimData.videoUri ?? null,
        status: 'Pending' as ClaimStatus,
        submissionDate: now,
        lastUpdatedDate: now,
        extractedInfo: currentExtractedInfoResult,
        fraudAssessment: fraudAssessmentResult,
        consistencyReport: consistencyReportResult,
        notes: newClaimData.notes ?? '', // Ensure notes is not undefined
      };
      console.log("addClaim: Before Firestore setDoc", newClaimForDb);
      if (!process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID || process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID === "undefined") {
        console.error("addClaim: Firebase Project ID is undefined. Cannot save to Firestore.");
        throw new Error("Firebase Project ID is not configured. Cannot save claim.");
      }
      await setDoc(doc(db, "claims", newClaimId), newClaimForDb);
      console.log("addClaim: After Firestore setDoc");

      const newClaimForState: Claim = {
        ...newClaimForDb,
        documentName: newClaimForDb.documentName === null ? undefined : newClaimForDb.documentName,
        documentUri: newClaimForDb.documentUri === null ? undefined : newClaimForDb.documentUri,
        videoName: newClaimForDb.videoName === null ? undefined : newClaimForDb.videoName,
        videoUri: newClaimForDb.videoUri === null ? undefined : newClaimForDb.videoUri,
        notes: newClaimForDb.notes === null ? undefined : newClaimForDb.notes,
        submissionDate: now.toDate().toISOString(),
        lastUpdatedDate: now.toDate().toISOString(),
      };

      setClaims(prevClaims => [newClaimForState, ...prevClaims].sort((a, b) => new Date(b.submissionDate).getTime() - new Date(a.submissionDate).getTime()));
      addNotification({ title: 'Claim Submitted to DB', message: `New claim #${newClaimForState.id.substring(0,12)}... by ${newClaimForState.claimantName} saved.`, type: 'success', claimId: newClaimForState.id });
      resetKycSession();
      console.log("addClaim: Successfully processed and returned claim", newClaimForState.id);
      return newClaimForState;

    } catch (error) {
      console.error("addClaim: Error in main try block:", error);
      addNotification({ title: 'Claim Submission Failed', message: `There was an error saving the claim or processing AI tasks. Details: ${error instanceof Error ? error.message : String(error)}`, type: 'error', claimId: newClaimId });
      return null;
    } finally {
      console.log("addClaim: Main finally block reached. Setting isLoading to false.");
      setIsLoading(false);
    }
  }, [addNotification, resetKycSession]);

  const updateClaimStatus = async (claimId: string, status: ClaimStatus, notes?: string) => {
    setIsLoading(true);
    const claimDocRef = doc(db, "claims", claimId);
    const newLastUpdatedDate = Timestamp.now();
    const updateData: Partial<Claim> & { lastUpdatedDate: Timestamp } = {
        status,
        lastUpdatedDate: newLastUpdatedDate,
    };
    if (notes !== undefined) {
        updateData.notes = notes;
    } else {
      updateData.notes = null; // Explicitly set to null if notes are undefined
    }


    try {
      if (!process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID || process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID === "undefined") {
        console.error("updateClaimStatus: Firebase Project ID is undefined. Cannot update Firestore.");
        throw new Error("Firebase Project ID is not configured. Cannot update claim.");
      }
      await updateDoc(claimDocRef, updateData as any);
      setClaims(prevClaims =>
        prevClaims.map(claim => {
          if (claim.id === claimId) {
            const updatedClaim = {
              ...claim,
              status,
              lastUpdatedDate: newLastUpdatedDate.toDate().toISOString(),
              notes: notes !== undefined ? notes : claim.notes, // Keep existing notes if new notes are undefined
            };
            addNotification({ title: 'Claim Updated in DB', message: `Claim #${claimId.substring(0,12)}... status changed to ${status}.`, type: 'info', claimId });
            return updatedClaim;
          }
          return claim;
        }).sort((a, b) => new Date(b.submissionDate).getTime() - new Date(a.submissionDate).getTime())
      );
    } catch (error) {
        console.error("Error updating claim status in Firestore:", error);
        addNotification({ title: 'DB Update Failed', message: `Could not update claim ${claimId}. Details: ${error instanceof Error ? error.message : String(error)}`, type: 'error', claimId });
    } finally {
        setIsLoading(false);
    }
  };

  const getClaimById = useCallback((claimId: string): Claim | undefined => {
    return claims.find(claim => claim.id === claimId);
  }, [claims]);

  const markNotificationAsRead = (notificationId: string) => {
    setNotifications(prev =>
      prev.map(notif =>
        notif.id === notificationId ? { ...notif, read: true } : notif
      )
    );
  };

  const clearNotifications = () => {
    setNotifications([]);
  };

  const completeKycSession = useCallback(() => {
    setIsKycVerifiedForSession(true);
  }, []);

  const askQuestionOnDocument = useCallback(async (documentDataUri: string, question: string, claimId?: string): Promise<string | null> => {
    if (!documentDataUri || !question.trim()) {
      const errorMsg = "Please provide a document and a question.";
      setQaAnswer(errorMsg);
      addNotification({ title: "Q&A Input Error", message: errorMsg, type: "warning", claimId });
      return errorMsg;
    }
    setIsAskingQuestion(true);
    setQaAnswer(null);
    try {
      const result = await qaOnDocument({ documentDataUri, question });
      setQaAnswer(result.answer);
      addNotification({ title: "AI Answer Received", message: "The AI has responded to your question.", type: "success", claimId });
      return result.answer;
    } catch (error) {
      console.error("Error asking question on document:", error);
      const errorMessage = `Sorry, I encountered an error trying to answer that question. The AI model might be unavailable or the document could not be processed. Details: ${error instanceof Error ? error.message : String(error)}`;
      setQaAnswer(errorMessage);
      addNotification({ title: "Q&A Error", message: `The AI could not answer your question. Details: ${error instanceof Error ? error.message : String(error)}`, type: "error", claimId });
      return errorMessage;
    } finally {
      setIsAskingQuestion(false);
    }
  }, [addNotification]);

  const clearQaAnswer = useCallback(() => {
    setQaAnswer(null);
  }, []);

  return (
    <AppContext.Provider
      value={{
        claims,
        notifications,
        addClaim,
        updateClaimStatus,
        getClaimById,
        addNotification,
        markNotificationAsRead,
        clearNotifications,
        isLoading: isLoading,
        isContextLoading: isLoading,
        isKycVerifiedForSession,
        completeKycSession,
        resetKycSession,
        askQuestionOnDocument,
        qaAnswer,
        isAskingQuestion,
        clearQaAnswer,
      }}
    >
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useAppContext must be used within an AppContextProvider');
  }
  return context;
};

